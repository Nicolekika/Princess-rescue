<script>
(() => {
  /* ---------- DOM ---------- */
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;

  const livesEl  = document.getElementById('lives');
  const heartsEl = document.getElementById('hearts');
  const timeEl   = document.getElementById('time');

  const dlgHow   = document.getElementById('how');
  const dlgShop  = document.getElementById('shop');
  const dlgRescue= document.getElementById('rescue');

  document.getElementById('btn-how').addEventListener('click', ()=>dlgHow.showModal());
  document.getElementById('btn-shop').addEventListener('click', ()=>dlgShop.showModal());
  document.getElementById('btn-replay')?.addEventListener('click', ()=>{ dlgRescue.close(); reset(); });

  /* ---------- AUDIO (MP3) ---------- */
  const bgm = document.getElementById('bgm');
  const soundBtn = document.getElementById('btn-audio'); // <-- match HTML id
  let musicOn = false;

  if (bgm && soundBtn) {
    bgm.volume = 0.15;
    soundBtn.textContent = 'ðŸ”‡ Lofi';

    async function toggleAudio() {
      try {
        if (!musicOn) {
          await bgm.play();
          musicOn = true;
          soundBtn.textContent = 'ðŸŽ§ Lofi';
        } else {
          bgm.pause();
          musicOn = false;
          soundBtn.textContent = 'ðŸ”‡ Lofi';
        }
      } catch {
        alert('Om det Ã¤r tyst: hÃ¶j volymen / slÃ¥ av tyst lÃ¤ge och klicka igen.');
      }
    }
    soundBtn.addEventListener('click', toggleAudio);

    // TillÃ¥t auto-start efter fÃ¶rsta tangenttryck (Safari/Chrome policy)
    document.body.addEventListener('keydown', async () => {
      if (!musicOn) { try { await bgm.play(); musicOn = true; soundBtn.textContent = 'ðŸŽ§ Lofi'; } catch {} }
    }, { once:true });
  }

  /* ---------- Input ---------- */
  const keys = {};
  addEventListener('keydown', e => keys[e.key] = true);
  addEventListener('keyup',   e => keys[e.key] = false);

  /* ---------- Game state ---------- */
  const sky='#ffe7f2', block='#ffe1ef', spike='#f6a0c1', heartC='#ff7aa2';
  let player, princess, platforms, movers, spikes, blobs, hearts, t0, got, lives, won;
  const GRAV=0.5, JUMP=10.2, SPEED=2.4, MAX_VY=16;

  function reset(){
    player={x:60,y:420,w:28,h:36,vx:0,vy:0,on:false,dir:1};
    princess={x:840,y:140,w:28,h:44};
    platforms=[[0,500,960,40],[160,440,120,16],[320,380,120,16],[520,320,120,16],[720,260,120,16],[780,180,140,16]];
    movers=[{x:240,y:480,w:100,h:16,dx:0,dy:-1.2,range:60,t:0},{x:610,y:360,w:90,h:16,dx:1.4,dy:0,range:80,t:0}];
    spikes=[[220,500,28],[248,500,28],[276,500,28],[420,500,28],[448,500,28],[476,500,28],[520,500,28],[548,500,28],[400,364,28],[580,308,28]];
    blobs=[{x:330,y:364,w:26,h:18,vx:1,minX:320,maxX:440},{x:740,y:244,w:26,h:18,vx:-1,minX:720,maxX:840}];
    hearts=[{x:185,y:400,t:false},{x:350,y:340,t:false},{x:550,y:280,t:false},{x:750,y:220,t:false},{x:880,y:150,t:false}];
    got=0; lives=3; won=false; t0=performance.now();
    livesEl.textContent=lives; heartsEl.textContent=got;
  }

  function overlap(a,b){ return a.x<b.x+b.w && a.x+a.w>b.x && a.y<b.y+b.h && a.y+a.h>b.y; }
  function triHit(px,py,ax,ay,bx,by,cx,cy){
    const v0x=cx-ax,v0y=cy-ay,v1x=bx-ax,v1y=by-ay,v2x=px-ax,v2y=py-ay;
    const d00=v0x*v0x+v0y*v0y,d01=v0x*v1x+v0y*v1y,d02=v0x*v2x+v0y*v2y,d11=v1x*v1x+v1y*v1y,d12=v1x*v2x+v1y*v2y;
    const inv=1/(d00*d11-d01*d01); const u=(d11*d02-d01*d12)*inv, v=(d00*d12-d01*d02)*inv;
    return (u>=0)&&(v>=0)&&((u+v)<1);
  }

  function update(dt){
    const left = keys['ArrowLeft']||keys['a']||keys['A'];
    const right= keys['ArrowRight']||keys['d']||keys['D'];
    const jump = keys['ArrowUp']||keys['w']||keys['W']||keys[' '];

    player.vx=0; if(left) player.vx=-SPEED,player.dir=-1; if(right) player.vx=SPEED,player.dir=1;
    player.vy+=GRAV; if(player.vy>MAX_VY) player.vy=MAX_VY;

    player.x+=player.vx;
    for(const p of platforms){ const r={x:p[0],y:p[1],w:p[2],h:p[3]};
      if(overlap(player,r)){ if(player.vx>0) player.x=r.x-player.w; else if(player.vx<0) player.x=r.x+r.w; } }

    player.y+=player.vy; player.on=false;
    for(const p of platforms){ const r={x:p[0],y:p[1],w:p[2],h:p[3]};
      if(overlap(player,r)){ if(player.vy>0){player.y=r.y-player.h;player.vy=0;player.on=true;} else if(player.vy<0){player.y=r.y+r.h;player.vy=0;} } }

    for(const m of movers){
      m.t+=dt; const ox=Math.sin(m.t*0.001)*m.range*m.dx, oy=Math.sin(m.t*0.001)*m.range*m.dy;
      const r={x:m.x+ox,y:m.y+oy,w:m.w,h:m.h};
      if(overlap(player,r)&&player.vy>=0){ player.y=r.y-player.h; player.vy=0; player.on=true; player.x+=(m.dx!==0?Math.cos(m.t*0.001)*m.range*0.03*m.dx:0); }
    }

    if(jump && player.on){ player.vy=-JUMP; player.on=false; }

    for(const s of spikes){ const[sx,sy,size]=s; const px=player.x+player.w/2, py=player.y+player.h-2;
      if(triHit(px,py,sx,sy,sx+size,sy,sx+size/2,sy-size)){ die(); break; } }

    for(const b of blobs){ b.x+=b.vx; if(b.x<b.minX||b.x+b.w>b.maxX) b.vx*=-1; if(overlap(player,b)){ die(); break; } }

    for(const h of hearts){ if(!h.t){ const dx=(player.x+player.w/2)-h.x, dy=(player.y+player.h/2)-h.y;
      if(Math.hypot(dx,dy)<20){ h.t=true; got++; heartsEl.textContent=got; } } }

    const r={x:princess.x,y:princess.y,w:princess.w,h:princess.h};
    if(got>=5 && overlap(player,r)){ dlgRescue.showModal(); won=true; if(musicOn) bgm.pause(); }

    const t=(performance.now()-t0)/1000; timeEl.textContent=t.toFixed(1)+'s';
  }

  function die(){ livesEl.textContent=--lives; if(lives<=0) reset(); else { player.x=60; player.y=420; player.vx=0; player.vy=0; } }

  function draw(){
    ctx.fillStyle=sky; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#fff'; for(let i=0;i<6;i++){ const x=(i*180)%W, y=60+((i%2)*30);
      ctx.globalAlpha=0.25; ctx.beginPath(); ctx.arc(x,y,40,0,Math.PI*2); ctx.arc(x+40,y+10,28,0,Math.PI*2); ctx.arc(x+80,y,36,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; }
    ctx.fillStyle='#d7f0ff'; ctx.fillRect(0,440,W,100);
    ctx.fillStyle=block; for(const p of platforms) ctx.fillRect(p[0],p[1],p[2],p[3]);
    for(const m of movers){ const ox=Math.sin(m.t*0.001)*m.range*m.dx, oy=Math.sin(m.t*0.001)*m.range*m.dy;
      ctx.fillStyle='#ffd6ec'; ctx.fillRect(m.x+ox,m.y+oy,m.w,m.h); }
    ctx.fillStyle=spike; for(const s of spikes){ const[x,y,size]=s; ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(x+size,y); ctx.lineTo(x+size/2,y-size); ctx.closePath(); ctx.fill(); }
    ctx.fillStyle='#c6a3ff'; for(const b of blobs) ctx.fillRect(b.x,b.y,b.w,b.h);
    for(const h of hearts){ if(h.t) continue; ctx.fillStyle=heartC;
      ctx.fillRect(h.x-2,h.y,4,4); ctx.fillRect(h.x-4,h.y+2,8,4); ctx.fillRect(h.x-6,h.y+4,12,4); ctx.fillRect(h.x-4,h.y+8,8,4); ctx.fillRect(h.x-2,h.y+10,4,4); }
    ctx.fillStyle='#ffb3c7'; ctx.fillRect(princess.x,princess.y,princess.w,princess.h);
    ctx.fillStyle='#222'; ctx.fillRect(player.x,player.y,player.w,player.h);
  }

  let last = performance.now();  // do NOT redeclare won
  won = false;

  function loop(t){
    const dt = t - last; last = t;
    if (!won) update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function initActors(){
    blobs=[{x:330,y:364,w:26,h:18,vx:1,minX:320,maxX:440},{x:740,y:244,w:26,h:18,vx:-1,minX:720,maxX:840}];
    hearts=[{x:185,y:400,t:false},{x:350,y:340,t:false},{x:550,y:280,t:false},{x:750,y:220,t:false},{x:880,y:150,t:false}];
  }

  initActors();
  reset();
  requestAnimationFrame(loop);
})();
</script>
